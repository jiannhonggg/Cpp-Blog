---
layout: post 
title: "Day 2 - Leetcode 961. N-Repeated Element in Size 2N Array"
date: 2026-01-02 10:00:00 +0800
category: [Leetcode]
tags: [Leetcode, Python]
# toc: true (Optional: false to hide the Table of Contents)
---
Welcome back to day 2 of the New Year, Today we have another Leetcode Easy. The N-Repeated Element in size 2N Array question <https://leetcode.com/problems/n-repeated-element-in-size-2n-array/>. Lets start by breaking down the question. We aim to find the element that appear N times in an array of size 2N with the following conditions : 

* nums.length == 2 * n 
* nums contain n+1 unqiue elements. 
* Exactly one element of nums in repeated n times. 

---
**Naive Approach:** 

We use a hash map to keep track of the frequency of all the elements in the array. We return the element that appeared exectly N times.

Time Complexity: O(N)

Space Complexity : O(N) 

```python
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        n = len(nums) / 2 

        hashMap = {} 
        for num in nums : 
            hashMap[num] = hashMap.get(num,0)+1 

        for key, value in hashMap.items() : 
            if value == n : 
                return key
                 
```
--- 
**Optimized Space Complexity Approach:**

For this paritcular question with the following properties we can further reduce the space complexity of the solution to O(1). The conditions mean that 50% of the array is the same number. 

Imagine the repeated element is a Pigeon and the other unique elements are Holes (spacers).
To keep the pigeons from seeing each other within a window of size 4, We would need to put at least 3 spacers between every pigeon But this would cause the Math to fail. 

1 Pigeon + 3 Spaces = 4 Slots used. 

N Pigeons + 3 Spacers = 4N solts needed. 

We only have 2N slots in this question. The numbers are forces to sit closer to each other. If we increase the gap by "stealing" spaces from others it would lead to crowding, and this will be what we use to solve this question. 

```python 
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        for i in range(len(nums)):
            if i >= 1 and nums[i] == nums[i - 1]: # Distance 1
                return nums[i]
            if i >= 2 and nums[i] == nums[i - 2]: # Distance 2
                return nums[i]
            if i >= 3 and nums[i] == nums[i - 3]: # Distance 3
                return nums[i]
```

Since the element appears in 50% of the slots, the Pigeonhole Principle ensures that even in the most distributed case, the repeated element must appear within a window of size 4. This allows us to find the element in O(N) time and O(1) space without needing a hash map.
---
layout: post 
title: "Day 1 - Leetcode 66. Plus One"
date: 2026-01-01 10:00:00 +0800
category: [Leetcode]
tags: [Leetcode, Python]
# toc: true (Optional: false to hide the Table of Contents)
---
Hello this will be a new series I am working on to keep myself accountable. I will be doing the Leetcode daily everyday for 2026. Hopefully I would be able to complete this without missing too many days. Thank you all for coming along with my journey. I will be using python first, and will slowly update this series with C++ in the future since I am currently more familiar with python. <https://leetcode.com/problems/plus-one/>

Starting off the year with an easy question. Our approach is simple, we iterate through the list backwards and check (digit + carry), and find the remainder and carry for the next number. The final carry would be added to the front of the list, in this case we use list concatenation in python. 

Time complexity would be O(n) since we travese the list once from the backward direction, space complexity would be O(1). 

```python

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        carry = 1 
        
        for i in reversed(range(len(digits))): 
            digit = digits[i] + carry 

            digits[i] = digit % 10
            carry = digit // 10 

        if carry > 0 : 
            digits = [carry] + digits 

        return digits
```
